# Put your writeup here
1.I started by implementing add(str), along with its helper method addSuffix. Add finds the furthest node that contains the word we are adding, and when it hits a dead end it calls addSuffix passing the current spot in the string, and the last node that contains a letter of the string. The add suffix adds each letter as the child of the previous node, (inserting at front), and then increments size by climbing back up at the end. My advance method creates temporary nodes if they do not exist, otherwise it just finds the node containing the letter. The only thing I changed in DLB node was adding a true node bool, which is true by default. By doing this, when advancing it creates a temporary node that sets true node to false. This allows my add() method to not have to go through every node, greatly speeding it up in the worst case. Instead, it just goes through all its parent nodes, incrementing the size variable and setting true node to true. This does not affect the retrieve prefix method, as it just checks that it is a valid node. If the current node is valid, it must have a valid child. To ensure that the auto predict can just go straight down the tree, we always insert false nodes not as the child but as the first sibling. However, advance is slowed down by this, as when we reset I am not clearing out the false nodes. This could easily be done by uncommenting out the code in reset, but then reset would take O(prediction.len). Depending on usage, I think this would likely be worth doing, but it would put retreat over the O(1) specified. This project went smoothly, my only issue was at first I was not making a deep copy of my prefix string in my get prediction method, which resulted in some strange behavior. Putting a breakpoint and tracing the method allowed me to identify the problem, and it was an easy fix. When I first implemented the true node, I was still inserting at the head of the linked list. However this made my other methods much more complicated, as I would have to traverse the linked list. Because of this, I decided to insert as the second entry in the linked list if the head already exists, preserving the insertion efficiency but removing any need to traverse through siblings in my get prediction method.
2. My public method **add(str)** takes O(alphabet size * word.len) in the worst case, which would occur when the dlb trie is full and the word we are adding is the last sibling on every level. **Advance** takes O(alphabet size) in the worst case, since it has to find  and update the current node. If the level is full and the letter is the last sibling this would occur. **Retreat** takes ùõâ (1) in every case, removing a char from a string builder and setting current node to its parent. **Reset** takes ùõâ (1) in every case as it just makes a new string builder, and sets current node to null. I commented it out, but because of how I implemented add, the dead nodes are still there. This does not slow down or effect retrieve prediction or adding based on user entered data. However, advance may be slightly affected by having to go through more entries. My commented out code would make reset take O(prefix length), but it would clear the dead nodes and make advance slightly more optimal. **Isword** takes ùõâ (1) in every case, as it just return current node .isword. The second **add()** which adds the current prefix takes O(prefix.len) in the worst case, which is faster then it is supposed to. Mine is more efficient as i have fake temporary nodes inserted in the advance method. This allows me just to advance up the tree and set them to true nodes. Get number of predictions just returns current node size and is ùõâ (1) in the worst case. **Retrieve prediction** is O(prediction .len) in the worst case, since it always advances to the first child.**My add() method is more efficient then specified, and everything else runs exactly as specified.**
